---
title: leveldb_table
tags:
---

# Table 的组成以及使用

table是一个牵涉文件较多的部分，包括内部block的解析，table的读取，写入等，下面一个一个部分解析

## Table Cache

file: table_cache.cc
对于每个table文件，.ldb或者sst结尾的，都用lrucache进行了打开描述符以及对应Table类的缓存，缓存由FindTable执行，由输入的filenumber作为cache的key，tableandfile类作为value。每次查找不存在cache中就保存，存在就直接获取。不论是iterator的构建，还是内部key的获取，都是通过指定filenumber的FindTable操作来实现的,并且两者都在最终自己析构的时候删除了对应cache的引用。
实际查找的时候会先后查找ldb和sst，前者是l0的，后者是sstable

## Table Builder
BuildTable 通过根据number创建一个TableFile,然后利用TableBuilder将iter传入的所有key和value全部加入，刷盘，最后利用tablecache读取进行检验。

TableBuilder中重要的部分都放在内部类Rep中，包含了data_block,index_block,以及可选的filter_block，每当Add之后，都会检测当前大小是否大于设定的block大小，是则通过Flush()立刻开始WriteBlock以及filterblock的写入工作，而indexblock entry的写入则是需要在开始下一个block的第一个key写入的时候才会去执行，根据注释，这样做的好处是indexblock使用的lastkey长度可以短一些，pending_index_entry就是用来判断什么时候更新indexblock的，一切都是为了节省空间。

WriteBlock 会使用BlockBuilder.Finish()获取之前在TableBuilder.Add中放入当前block的所有content，根据option以及压缩率决定是否压缩，然后WriteRawBlock执行具体的写入操作, 这里面会直接写入文件，然后是type 1字节(压缩与否),然后是4字节的crc，同时更新BlockHandle(用来给上层后期利用blockhandle记录位置,**注意这里的handle的size是不包括后面的type和crc的**),这个用来在不同的函数间交互指示当前刚刚写入的block的offset以及size，用来在下次更新indexblock时用作其内容，indexblock就是超过lastkey，却小于下一个block firstkey的最短key，对应一个blockhandle

在TableBuilder的使用中，Add结束后是调用Finish(),此时所有datablock已经写完。这里会首先写入filterblock，同时记录blockhandle(所有的filterblock在之前每次datablock Flush的时候都会相应StartBlock(offset),但是不会写入file，而是在这个时候进行filterblock->Finish()然后统一写入文件,同时记录对应handle。之后的metaindexblock就是记录这个handle，用的kv是filtername 与filter的blockhandle, 将其也写入作为一个metaindexblock,记录的是所有meta的开头以及所有的size到metaindexblockhandle。 然后填充最后indexblock entry的对应lastkey和handle, 整理成index block之后写入,记下indexblockhandle.
最后在Footer中把这两个handle记录下来，具体格式是doc/table_format.md所示，使用的时候通过blockindex找block，通过metaindex找meta, 每个index里面都是多个entry

注:这里看起来挺不一致的，先datablock,再filterblock，再一个metaindexblock单个entry记录filterblock区段的head以及size，再indexblock分多个entry记录不同的block对应的位置，最后footer中记录metaindexblock位置以及indexblock的位置和长度。<br/>
在设计上，是支持多个filter类型的，每个filter放入一个filterblock，而metaindexblock是记录所有filterblock的地方，和indexblock是同级的，只不过当前代码里只支持单个filter，即bloomfilter。

## BlockBuilder
被TableBuiler利用，使用Add与Finish方法工作，但是Finish会返回内部所有处理好的字符串,外部处理完后需要Reset，才能继续接收下一个Block的数据。单个block的结构很简单，每options_->block_restart_interval个entry开头都会放一个完整的entry，并且restart array记录这个entry的起始位置，其余的key都和上一个key比对，省略共同的部分，每个entry的结构是 sharedbytes(varint32)|unsharedbytes(varint32)|vallen(varint32)|nonshared_key_data|val_data ,最后finish的之后把所有的restart point以fix的形式添加到末尾,再添加restartpoint的数量即可, 这就是一个block。 对于indexblock区别就是 block_restart_interval 的值强制设置1，表示每条都是完整的

## FilterBlockBuilder
filter block内部包含了众多的filter，每个管理一个block的key，在tablebuiler中每次flush中会使用startblock的GenerateFilter中完成到当前offset位置对应的filterblock(每个filterblock管理2k数据,但实际上只有tablebuiler调用startblock，也就是block内总数据量达到block_size的时候才会切换，这个应该会导致某个filterblock对应的key很多，而第二个直接为0才对(待测试),所有的filterblockoffset都存放在一个数组中，最后finish的时候写入所有filter的blockoffset，最后是这些offset的开头位置,最后是logbase，结束。<br/>
在read的时候，则是根据blockoffset来反推所属的filterblock的位置的，这里感觉有不准确的地方，filterblock是每2k的offset属于一个，但是当时generatefilter的时候是根据单个block预估超过4k大小的时候才会StartBlock，既而产生一个包罗了当前所有key的filter，其结果是可能横跨两个filter，第一个包含所有key信息，第二个为空，也就是会出现部分key无法match，不得不搜索table来检测。 再看block offset似乎对应的就是那个block指定的filter，应该不会出现上面说的情况的。


## Block

block.cc的作用是提供迭代器，每次定位到一条entry上，然后外部通过iter.key(), iter.value()得到对应的kv,如果失败或遍历耗尽，返回invalid的iterator

- 每次的跳跃性定位,包括Prev，Seek，First，Last，都是通过首先Seektorestartpoint(对于Seek,无法事先得知需要seek到哪里，所以需要利用二分查找找到最大的小于target的restartpoint，然后按序查找),然后按序查找。SeekToRestartPoint本身会把value_定义成一个offset，在ParseNextEntry的时候会利用这个实现parse吓一条指令，就像上次调用的是parseNextEntry一样。
- Seek实际会找到大于等于target的key，或者返回invalid的iterator
- binary search: left至少是第一个restartpoint的位置，同时会不断右移，但是永远保持小于target,所有的情况是
    1. target小于所有key，那么left最后就是他本身，不动，然后返回的key就是当前block中最小的那个
    2. target大于所有key，返回最后一个
    3. target为某个restartpoint，这个会匹配到第二个分支，导致接下来的while循环需要遍历一个restartpoint interval的长度
    4. target为某两个之间，最普通的匹配情况。

对于二分查找的找相同数中最左边的，最右边的，亦或是最普通的二分查找，这个需要好好理解一下，也是面试重点。

## Table

table.cc的作用是根据打开的文件，从footer中得到对应的indexblock,同时根据fitler的option设定读取metaindexblock中对应名字的filter的block(利用ReadMeta 以及 ReadFilter,之后根据传入的key和block offset利用filter判断)。主要的读取工作由ReadBlock完成，内部根据指定位置的handle读取block以及末尾的crc和压缩type，对于需要解压的，以及reader内部没有提供存储位置的，可以设定cachable，这样后期读出的block可以缓存,每张table都会设定自己的cache，利用生成的id以及block的index。

BlockReader返回的是上面分析的Block的iterator，基于传入的index_handle,这里会通过操作缓存(contents.cachable && options.fill_cache的前提下)减少磁盘读取，这里对应了几个callback，从cache完全删除的时候，需要DeleteCachedBlock, 没有cache的情况下iter析构也需要DeleteBlock， 有cache的情况下iter需要ReleaseBlock

InternalGet 利用每个indexblock存储的key是比当前对应range中key大的这个特点，使用seek在indexblock中搜索，seek返回的是比target大的key，那么这里返回的就是正好匹配到需要get的userkey对应的block(也有可能是invalid,如果太大或者太小,对于太小的情况需要接下来的block的iter中的，通过对block第一个key的比较才能识别),之后利用indexblock中对应的handle，使用blockreader返回的iter进行seek，调用callback处理。

ApproximateOffsetOf 只是返回key所在block的起始位置，如果key小于所有，应该返回0,大于所有，会返回metaindexblock的起始位置，也就是filterblock的终点。

## iterator

### Iterator

基类，RegisterCleanup没有顺序保证。

### IteratorWrapper

这只是个wrapper，主要是缓存key的读取，其他没什么

### TwoLevelIterator

这个似乎是专用与block/table层级遍历的。上层 index每次移动一个indexblock，下层每次移动一个entry,每次移动后，调用SkipEmptyDataBlocksXXX来解决下层eof的情况: 上层 移动一格，下层InitDataBlock初始化新的block_index的iterator(这里是BlockReader返回的iterator)

### MergingIterator

这个只管理一层多个iterator，利用归并排序，每次next的时候都会返回所有中当前最接近的next,然后返回，支持prev,next操作,负责iterator的delete
